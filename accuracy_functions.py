# -*- coding: utf-8 -*-
"""
Created on Wed Feb 10 22:27:43 2021

@author: Natalia Åšlusarz


a file with methods involving accuracy using CED and nn_class
methods involve:
    measuring accuracy for networks of various sizes
    measuring accuracy against adversarial examples (BIM and FGSM generated)
    measuring accuracy against random variation of data
"""


import matplotlib.pyplot as plt
plt.style.use('seaborn-whitegrid')
import numpy as np
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

from spiral import *
from nn_class import *


'''
display accuracy for tanh and ReLu based NNs with varied amount of neurons in layer
neurons_in_layer - array of the form [a, b, ... ,e] with a, b, ..., e 
being the amounts of neurons in each hidden layer for different networks
'''
def accuracy(neurons_in_layer):
    for i in neurons_in_layer:
        nn = MLP([i,i,i,i,i],2,'relu')
        nn.train(
            epochs=100, batches=50, x_train=x_train, y_train=y_train, 
            optimiser=optimiser)
        nn.test(x_val, y_val, 10)
        acc_ls_relu.append(nn.test_accuracy)
        
        nn = MLP([i,i,i,i,i],2,'tanh')
        nn.train(
            epochs=100, batches=50, x_train=x_train, y_train=y_train, 
            optimiser=optimiser)
        nn.test(x_val, y_val, 10)
        acc_ls_tanh.append(nn.test_accuracy)

    plt.figure(dpi=300)
    plt.plot(neurons_in_layer, acc_ls_tanh, label='tanh')
    plt.scatter(neurons_in_layer, acc_ls_tanh)
    plt.plot(neurons_in_layer, acc_ls_relu, label='relu')
    plt.scatter(neurons_in_layer, acc_ls_relu)

    plt.yticks(ticks=np.arange(0, 110, 10))
    plt.legend()
    plt.xlabel('Number of neurons in single hidden layer')
    plt.ylabel('Test accuracy')
    plt.title('Accuracy depending on amount of neurons in a single hidden layer \n in a NN with 5 hidden layers ({})'.format(
        optimiser))
    plt.show()
        
'''
plot accuracy of the networks with tanh and relu with training sets 
with random variation increasing up to max_val
takes parameters to control the spiral dataset (entanglemtns, min_phi, samples)
'''
def accuracy_mod_set(max_val, epochs, hidden_layers, entanglement = 10, min_phi = 1, num_samples=1000, radius=2):
    acc_relu = []
    acc_tanh = []
    x = []
    max_r = 0
    max_t = 0
    min_r = 100
    min_t = 100
    spiral = Data_spiral(ent=entanglement, min_phi = min_phi, num_samples=num_samples, radius=radius)
    net = MLP(hidden_layers,2, activ='tanh')
    spiral.generate_data()
    x_train, x_val, y_train, y_val, = train_test_split(spiral.x_data, spiral.y_data, test_size=0.33, random_state=55)
    net.train(epochs, 50, x_train, y_train, 'Adam')
    net.test(x_val, y_val)
    acc_tanh.append(net.test_accuracy)
    x.append(0)
    for i in range(1, max_val, 1):
        var = i/10
        spiral.generate_adjacant_data(var)
        x_train, x_val, y_train, y_val = train_test_split(spiral.x_data, spiral.y_data, test_size=0.33, random_state=55)
        net.test(x_val, y_val)
        acc_tanh.append(net.test_accuracy)
        net.plot_decision_boundary(x_val, y_val)
        max_t = max(max_t, net.test_accuracy)
        min_t = min(min_t, net.test_accuracy)
        x.append(var)
        
    net = MLP(hidden_layers,2, activ='relu')
    spiral.generate_data()
    x_train, x_val, y_train, y_val = train_test_split(spiral.x_data, spiral.y_data, test_size=0.33, random_state=55)
    net.train(epochs, 50, x_train, y_train, 'Adam')
    net.test(x_val, y_val)
    acc_relu.append(net.test_accuracy)
    for i in range(1, 20, 1):
        var = i/10
        spiral.generate_adjacant_data(var)
        x_train, x_val, y_train, y_val = train_test_split(spiral.x_data, spiral.y_data, test_size=0.33, random_state=55)
        net.test(x_val, y_val)
        acc_relu.append(net.test_accuracy)
        net.plot_decision_boundary(x_val, y_val)
        max_r = max(max_r, net.test_accuracy)
        min_r = min(min_r, net.test_accuracy)
        
    print ('tanh max ', max_t)
    print ('tanh min ', min_t)
    print ('relu max ', max_r)
    print ('relu min ', min_r)
        
    plt.figure(dpi=500)
    plt.plot(x, acc_tanh, label='tanh')
    plt.scatter(x, acc_tanh)
    plt.plot(x, acc_relu, label='relu')
    plt.scatter(x, acc_relu)

    plt.yticks(ticks=np.arange(0, 110, 10))
    plt.legend()
    plt.xlabel('Maximum distance from spiral alongside one of the axis')
    plt.ylabel('Test accuracy')
    plt.title('Accuracy depending on variance in the test set')
    
    
'''
plot accuracy of the networks with tanh and relu against adversarial examples
 generated by FGSM method
'''
def FGSM_accuracy(epsilons, hidden_layers, epochs, batchsize, x_train, y_train, x_val, y_val):
       
    net = MLP(hidden_layers, 2, activ='relu' )
    net.train(epochs,batchsize, x_train, y_train, 'Adam')
    x1 = []
    y1 = []
    for epsilon in epsilons:
        y1.append(net.generate_adversarial_fgsm(x_val, y_val, epsilon)*100)
        x1.append(epsilon)
    
    net = MLP(hidden_layers, 2, activ='tanh' )
    net.train(epochs,batchsize, x_train, y_train, 'Adam')
    x2 = []
    y2 = []
    for epsilon in epsilons:
        y2.append(net.generate_adversarial_fgsm(x_val, y_val, epsilon)*100)
        x2.append(epsilon)
    
    plt.figure(dpi=500)
    
    plt.plot(x1, y1, label = 'relu')
    plt.scatter(x1, y1)
    plt.plot(x2, y2, label = 'tanh')
    plt.scatter(x2, y2)

    plt.yticks(ticks=np.arange(0, 110, 10))
    plt.legend()
    plt.xlabel('Epsilon')
    plt.ylabel('Accuracy (%)')
    plt.title('Accuracy on sets of adversarial examples (FGSM) depending on epsilon')   
       
    
    
''''
plot accuracy for adversarial examples for tanh and relu 
with BIM method of generating adversarial examples
'''
def BIM_accuracy(epsilons, hidden_layers, epochs, batchsize, alpha, iterations, x_train, y_train, x_val, y_val):
      
    net = MLP(hidden_layers, 2, activ='relu' )
    net.train(epochs,batchsize, x_train, y_train, 'Adam')
    x1 = []
    y1 = []
    for epsilon in epsilons:
        y1.append(net.generate_adversarial_bim(x_val, y_val, epsilon, iterations)*100)
        x1.append(epsilon)
    
    net = MLP(hidden_layers, 2, activ='tanh' )
    net.train(epochs,batchsize, x_train, y_train, 'Adam')
    x2 = []
    y2 = []
    for epsilon in epsilons:
        y2.append(net.generate_adversarial_bim(x_val, y_val, epsilon, iterations)*100)
        x2.append(epsilon)
    
    plt.figure(dpi=500)
    
    plt.plot(x1, y1, label = 'relu')
    plt.scatter(x1, y1)
    plt.plot(x2, y2, label = 'tanh')
    plt.scatter(x2, y2)

    plt.yticks(ticks=np.arange(0, 110, 10))
    plt.legend()
    plt.xlabel('Epsilon')
    plt.ylabel('Accuracy (%)')
    plt.title('Accuracy on sets of adversarial examples (BIM) depending on epsilon')

